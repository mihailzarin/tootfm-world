generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id             String         @id @default(cuid())
  worldId        String         @unique
  primaryId      String?        @unique @default(cuid())
  credentialType String?
  verified       Boolean        @default(true)
  
  // Google OAuth fields
  googleId       String?        @unique
  email          String?        @unique
  emailVerified  Boolean        @default(false)
  
  // Profile fields
  displayName    String?
  avatar         String?
  level          String?        @default("guest")
  
  // Timestamps
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt
  lastLogin      DateTime?
  
  // Relations
  musicProfile   MusicProfile?
  musicServices  MusicService[]
  createdParties Party[]        @relation("PartyCreator")
  joinedParties  PartyMember[]
  syncHistory    SyncHistory[]
  addedTracks    Track[]        @relation("TrackAdder")
  votes          Vote[]

  @@index([primaryId])
  @@index([email])
  @@index([googleId])
}

model Party {
  id          String        @id @default(cuid())
  code        String        @unique
  name        String
  description String?
  isActive    Boolean       @default(true)
  isPublic    Boolean       @default(false)
  creatorId   String
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  creator     User          @relation("PartyCreator", fields: [creatorId], references: [id])
  members     PartyMember[]
  tracks      Track[]

  @@index([code])
  @@index([creatorId])
}

model PartyMember {
  id       String   @id @default(cuid())
  userId   String
  partyId  String
  role     String   @default("member")
  joinedAt DateTime @default(now())
  party    Party    @relation(fields: [partyId], references: [id])
  user     User     @relation(fields: [userId], references: [id])

  @@unique([userId, partyId])
  @@index([partyId])
  @@index([userId])
}

model Track {
  id        String   @id @default(cuid())
  spotifyId String
  name      String
  artist    String
  album     String?
  albumArt  String?
  duration  Int
  partyId   String
  addedById String
  addedAt   DateTime @default(now())
  voteCount Int      @default(0)
  addedBy   User     @relation("TrackAdder", fields: [addedById], references: [id])
  party     Party    @relation(fields: [partyId], references: [id])
  votes     Vote[]

  @@unique([spotifyId, partyId])
  @@index([partyId])
}

model Vote {
  id        String   @id @default(cuid())
  userId    String
  trackId   String
  value     Int
  createdAt DateTime @default(now())
  track     Track    @relation(fields: [trackId], references: [id])
  user      User     @relation(fields: [userId], references: [id])

  @@unique([userId, trackId])
  @@index([trackId])
  @@index([userId])
}

model MusicService {
  id              String      @id @default(dbgenerated("gen_random_uuid()"))
  userId          String
  service         ServiceType
  accessToken     String?
  refreshToken    String?
  expiresAt       DateTime?
  serviceUserId   String?
  serviceUserName String?
  serviceEmail    String?
  connectedAt     DateTime    @default(now())
  lastSyncAt      DateTime?
  syncCount       Int         @default(0)
  autoSync        Boolean     @default(true)
  syncInterval    Int         @default(3600)
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @default(now()) @updatedAt
  user            User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, service])
  @@unique([service, serviceUserId])
  @@index([userId])
  @@index([service])
  @@index([serviceUserId])
}

model MusicProfile {
  id                 String   @id @default(dbgenerated("gen_random_uuid()"))
  userId             String   @unique
  topTracks          Json     @default("[]")
  topArtists         Json     @default("[]")
  topGenres          Json     @default("[]")
  topAlbums          Json?
  totalListeningTime Int?
  uniqueTracks       Int?
  uniqueArtists      Int?
  averageTrackAge    Int?
  musicPersonality   String?
  energyLevel        Float?   @default(0.5)
  danceability       Float?   @default(0.5)
  diversityScore     Float?   @default(0.5)
  mainstreamScore    Float?   @default(0.5)
  genreVector        Float[]  @default([])
  audioFeatureVector Float[]  @default([])
  calculatedAt       DateTime @default(now())
  createdAt          DateTime @default(now())
  updatedAt          DateTime @default(now()) @updatedAt
  lastUpdated        DateTime @default(now())
  version            Int      @default(1)
  user               User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model SyncHistory {
  id           String      @id @default(dbgenerated("gen_random_uuid()"))
  userId       String
  service      ServiceType
  status       SyncStatus
  tracksAdded  Int         @default(0)
  artistsAdded Int         @default(0)
  errorMessage String?
  duration     Int?
  apiCalls     Int?
  startedAt    DateTime    @default(now())
  completedAt  DateTime?
  user         User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, service])
  @@index([startedAt])
}

enum ServiceType {
  SPOTIFY
  APPLE
  LASTFM
  YOUTUBE
  SOUNDCLOUD
  TIDAL
  GOOGLE
}

enum SyncStatus {
  SUCCESS
  PARTIAL
  FAILED
  IN_PROGRESS
}